//go:generate go run ./cmd/gen_errors/gen.go
package errz

import (
	"errors"
	"fmt"
	"sort"
	"strings"
)

var ErrLenErrors = errors.New("no error definitions provided")

// GenerateGoContent generates the Go code content from error definitions.
func GenerateGoContent(errors map[string]ErrorDefinition) (string, error) {
	if len(errors) == 0 {
		return "", ErrLenErrors
	}

	// Sort error codes alphabetically for consistent ordering
	var codes []string
	for code := range errors {
		codes = append(codes, code)
	}
	sort.Strings(codes)

	var builder strings.Builder

	// Header
	builder.WriteString("// Code generated by errz/gen_go.go; DO NOT EDIT.\n")
	builder.WriteString("package errz\n\n")

	builder.WriteString("import \"fmt\"\n\n")

	// Error struct definition
	builder.WriteString("// Error represents a centralized error definition.\n")
	builder.WriteString("type Error struct {\n")
	builder.WriteString("\tDomain      string\n")
	builder.WriteString("\tCode        string\n")
	builder.WriteString("\tMsg         string\n")
	builder.WriteString("\tCause       string\n")
	builder.WriteString("}\n\n")

	// Implement error interface
	builder.WriteString("func (e *Error) Error() string {\n")
	builder.WriteString("\treturn fmt.Sprintf(\"[Domain: %s] [Code: %s] Msg: %s | Cause: %s\",\n")
	builder.WriteString("\t\te.Domain, e.Code, e.Msg, e.Cause)\n")
	builder.WriteString("}\n\n")

	// Individual error variables
	builder.WriteString("var (\n")
	for _, code := range codes {
		errDef := errors[code]
		builder.WriteString(fmt.Sprintf("\t%s = &Error{\n", code))
		builder.WriteString(fmt.Sprintf("\t\tDomain: \"%s\",\n", Escape(errDef.Domain)))
		builder.WriteString(fmt.Sprintf("\t\tCode: \"%s\",\n", Escape(errDef.Code)))
		builder.WriteString(fmt.Sprintf("\t\tMsg: \"%s\",\n", Escape(errDef.Msg)))
		builder.WriteString(fmt.Sprintf("\t\tCause: \"%s\",\n", Escape(errDef.Cause)))
		builder.WriteString("\t}\n")
	}
	builder.WriteString(")\n\n")

	return builder.String(), nil
}

func Escape(s string) string {
	replacer := strings.NewReplacer(
		`"`, `\"`,
		`\`, `\\`,
		"\n", `\n`,
	)

	return replacer.Replace(s)
}
