//go:generate go run ./cmd/gen_errors/gen.go
package errz

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"unicode"

	"golang.org/x/sync/errgroup"
)

type Generator struct {
	SchemaPath     string
	DefinitionsDir string
	OutputPath     string
	OutputDocDir   string
}

func (g *Generator) Run() error {
	var errors map[string]Error

	var eg errgroup.Group

	eg.Go(func() error {
		return validateAllJSONFiles(g.SchemaPath, g.DefinitionsDir)
	})

	eg.Go(func() error {
		var err error
		errors, err = loadErrorDefinitions(g.DefinitionsDir)
		return err
	})

	if err := eg.Wait(); err != nil {
		return err
	}

	// Generate code content
	return generate(g.OutputPath, g.OutputDocDir, errors)
}

func generate(outputPath, outputDirPath string, errors map[string]Error) error {
	path := strings.ToLower(outputPath)
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return fmt.Errorf("failed to create output dir: %w", err)
	}

	// Write the errz_gen.go file.
	err := writeGoFile(outputPath, errors)
	if err != nil {
		return fmt.Errorf("failed to write go content: %w", err)
	}

	domainGroups := make(map[string]map[string]Error)
	for code, def := range errors {
		domain := def.Domain
		if domain == "" {
			return fmt.Errorf("error code %q has empty domain", code)
		}

		if _, ok := domainGroups[domain]; !ok {
			domainGroups[domain] = make(map[string]Error)
		}

		domainGroups[domain][code] = def
	}

	for domain, group := range domainGroups {
		if err := writeMarkdownFile(outputDirPath, domain, group); err != nil {
			return fmt.Errorf("failed to write markdown for domain %q: %w", domain, err)
		}
	}

	return nil
}

var errLenErrors = errors.New("no error definitions provided")

// generateGoContent generates the Go code content from error definitions.
func generateGoContent(errors map[string]Error) (string, error) {
	if len(errors) == 0 {
		return "", errLenErrors
	}

	// Sort error codes alphabetically for consistent ordering
	var codes []string
	for code := range errors {
		codes = append(codes, code)
	}
	sort.Strings(codes)

	var builder strings.Builder

	// Header
	builder.WriteString("// Code generated by gen_errors/gen.go; DO NOT EDIT.\n")
	builder.WriteString("package errz\n\n")

	builder.WriteString("import \"fmt\"\n\n")

	// Error struct definition
	builder.WriteString("// Error represents a centralized error definition.\n")
	builder.WriteString("type Error struct {\n")
	builder.WriteString("\tDomain      string\n")
	builder.WriteString("\tCode        string\n")
	builder.WriteString("\tMsg         string\n")
	builder.WriteString("\tCause       string\n")
	builder.WriteString("}\n\n")

	// Implement error interface
	builder.WriteString("func (e *Error) Error() string {\n")
	builder.WriteString("\treturn fmt.Sprintf(\"[Domain: %s] [Code: %s] Msg: %s | Cause: %s\",\n")
	builder.WriteString("\t\te.Domain, e.Code, e.Msg, e.Cause)\n")
	builder.WriteString("}\n\n")

	// Individual error variables
	builder.WriteString("var (\n")
	for _, code := range codes {
		errDef := errors[code]
		builder.WriteString(fmt.Sprintf("\t%s = &Error{\n", code))
		builder.WriteString(fmt.Sprintf("\t\tDomain: \"%s\",\n", escape(errDef.Domain)))
		builder.WriteString(fmt.Sprintf("\t\tCode: \"%s\",\n", escape(errDef.Code)))
		builder.WriteString(fmt.Sprintf("\t\tMsg: \"%s\",\n", escape(errDef.Msg)))
		builder.WriteString(fmt.Sprintf("\t\tCause: \"%s\",\n", escape(errDef.Cause)))
		builder.WriteString("\t}\n")
	}
	builder.WriteString(")\n\n")

	return builder.String(), nil
}

func escape(s string) string {
	replacer := strings.NewReplacer(
		`"`, `\"`,
		`\`, `\\`,
		"\n", `\n`,
	)

	return replacer.Replace(s)
}

var (
	titleCache sync.Map // map[string]string
)

var errInvalidDomainName = errors.New("domain name must be non-empty and alphanumeric")

// generateMarkdownContent builds Markdown content for a given domain and its errors.
func generateMarkdownContent(domain string, errors map[string]Error) (string, error) {
	if strings.TrimSpace(domain) == "" || strings.ContainsAny(domain, " ./\\") {
		return "", errInvalidDomainName
	}

	if len(errors) == 0 {
		// TODO: This should use the errLenErrors from above, but it causes a cycle.
		// For now, create a new error. This should be addressed.
		return "", fmt.Errorf("no error definitions provided for markdown generation")
	}

	// Sort error codes alphabetically for consistent ordering
	var codes []string
	for code := range errors {
		codes = append(codes, code)
	}
	sort.Strings(codes)

	var builder strings.Builder
	// Estimate rough capacity: header + rows + details (~300 bytes per error)
	builder.Grow(500 + len(codes)*300)

	builder.WriteString(normalizeMarkdownTitle(domain))

	// Write Markdown header
	builder.WriteString("| Code | Message |\n")
	builder.WriteString("|:-----:|:-----------:|\n")

	// Write each error row
	for _, code := range codes {
		errDef := errors[code]
		builder.WriteString(fmt.Sprintf(
			"| %s | %s |\n",
			errDef.Code,
			escapeMarkdownInline(errDef.Msg),
		))
	}

	builder.WriteString("\n---\n\n")

	// Full error details
	for _, code := range codes {
		errDef := errors[code]
		builder.WriteString(fmt.Sprintf("## %s\n\n", code))
		builder.WriteString(fmt.Sprintf("- **Domain**: %s\n", errDef.Domain))
		builder.WriteString(fmt.Sprintf("- **Code**: %s\n", errDef.Code))
		builder.WriteString(fmt.Sprintf("- **Message**: %s\n", escapeMarkdownBlock(errDef.Msg)))
		builder.WriteString(fmt.Sprintf("- **Cause**: %s\n", errDef.Cause)) // Cause is already escaped in Go content
	}

	output := builder.String()
	output = strings.TrimRight(output, "\n") + "\n"
	return output, nil

}

// escapeMarkdownInline escapes Markdown inline content (e.g., table cells)
func escapeMarkdownInline(text string) string {
	return strings.ReplaceAll(text, "|", "\\|")
}

// escapeMarkdownBlock escapes Markdown block content (e.g., details)
func escapeMarkdownBlock(text string) string {
	return strings.ReplaceAll(text, "`", "\\`")
}

// normalizeMarkdownTitle formats the domain into a Markdown header with each
// hyphen-separated part capitalized (first letter uppercase, rest lowercase).
// Results are cached for improved performance and concurrency safety.
func normalizeMarkdownTitle(domain string) string {
	if cached, ok := titleCache.Load(domain); ok {
		return cached.(string)
	}

	parts := strings.Split(domain, "-")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}

		p = strings.ToLower(p)
		runes := []rune(p)
		runes[0] = unicode.ToUpper(runes[0])
		parts[i] = string(runes)
	}

	result := "# " + strings.Join(parts, "-") + " Errors\n\n"
	titleCache.Store(domain, result)

	return result
}

var (
	errEmptyPath = errors.New("path cannot be empty")
	errEmptyFile = errors.New("output file path cannot be empty")
	errEmptyDir  = errors.New("directory path cannot be empty")
)

func writeGoFile(outputPath string, errors map[string]Error) error {
	if strings.TrimSpace(outputPath) == "" {
		return errEmptyFile
	}

	content, err := generateGoContent(errors)
	if err != nil {
		return fmt.Errorf("failed to generate Go content: %w", err)
	}

	if err := writeToFile(outputPath, content); err != nil {
		return fmt.Errorf("failed to write Go file: %w", err)
	}

	return nil
}

func writeMarkdownFile(outputDirPath, domain string, errors map[string]Error) error {
	if strings.TrimSpace(outputDirPath) == "" {
		return errEmptyDir
	}

	domainLower := strings.ToLower(domain)
	domainDir := filepath.Join(outputDirPath, domainLower)

	if err := os.MkdirAll(domainDir, 0755); err != nil {
		return fmt.Errorf("failed to create documentation sub directory: %w", err)
	}

	filename := filepath.Join(domainDir, fmt.Sprintf("%s.md", domainLower))
	content, err := generateMarkdownContent(domain, errors)
	if err != nil {
		return fmt.Errorf("failed to generate markdown content: %w", err)
	}

	if err := writeToFile(filename, content); err != nil {
		return fmt.Errorf("failed to write markdown file: %w", err)
	}

	return nil
}

// writeToFile writes content to the specified file path.
func writeToFile(path, content string) error {
	if strings.TrimSpace(path) == "" {
		return errEmptyPath
	}

	return os.WriteFile(path, []byte(content), 0644)
}
